/*--
 ClustepDiag.java - Created October 30, 2012

 Copyright (c) 2009-2013 Flavio Miguel ABREU ARAUJO.
 Université catholique de Louvain, Louvain-la-Neuve, Belgium
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:

 1. Redistributions of source code must retain the above copyright
 notice, this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions, and the disclaimer that follows
 these conditions in the documentation and/or other materials
 provided with the distribution.

 3. The names of the author may not be used to endorse or promote
 products derived from this software without specific prior written
 permission.

 In addition, we request (but do not require) that you include in the
 end-user documentation provided with the redistribution and/or in the
 software itself an acknowledgement equivalent to the following:
 "This product includes software developed by the
 Abinit Project (http://www.abinit.org/)."

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED.  IN NO EVENT SHALL THE JDOM AUTHORS OR THE PROJECT
 CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

 For more information on the Abinit Project, please see
 <http://www.abinit.org/>.
 */

package MDandTB;

import core.MainFrame;
import core.RetMSG;
import core.Utils;
import java.awt.Color;
import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import javax.swing.JCheckBox;
import javax.swing.JFileChooser;
import javax.swing.JTextField;
import projects.LocalMachine;
import projects.Machine;

/**
 *
 * @author flavio
 */
public class ClustepDiag extends javax.swing.JDialog {

    private MainFrame MF;

    /**
     * Creates new form ClustepDiag
     */
    public ClustepDiag(java.awt.Frame parent, boolean modal) {
        super(parent, modal);
        initComponents();
        MF = (MainFrame) parent;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        openClustepInputFileLabel = new javax.swing.JLabel();
        displayClustepInputFileButton = new javax.swing.JButton();
        geditClustepInputButton = new javax.swing.JButton();
        openClustepInputFileDialogButton = new javax.swing.JButton();
        openClustepInputFileTextField = new javax.swing.JTextField();
        openClustepPositionFileLabel = new javax.swing.JLabel();
        displayClustepPositionFileButton = new javax.swing.JButton();
        geditClustepPositionButton = new javax.swing.JButton();
        openClustepPositionFileDialogButton = new javax.swing.JButton();
        openClustepPositionFileTextField = new javax.swing.JTextField();
        sendSIMClustepButton = new javax.swing.JButton();
        sendClustepCheckBox = new javax.swing.JCheckBox();
        getEvolutionFileButton = new javax.swing.JButton();
        getFilmFileButton = new javax.swing.JButton();
        needSGECheckBox = new javax.swing.JCheckBox();
        SGEconfigPanel = new javax.swing.JPanel();
        timeLabel = new javax.swing.JLabel();
        nodesLabel = new javax.swing.JLabel();
        ramLabel = new javax.swing.JLabel();
        hdmLabel = new javax.swing.JLabel();
        timeTextField = new javax.swing.JTextField();
        nodesTextField = new javax.swing.JTextField();
        ramTextField = new javax.swing.JTextField();
        hdmTextField = new javax.swing.JTextField();
        emailLabel = new javax.swing.JLabel();
        emailTextField = new javax.swing.JTextField();
        sequentialCheckBox = new javax.swing.JCheckBox();
        parallelCheckBox = new javax.swing.JCheckBox();
        abinitParaTextField = new javax.swing.JTextField();
        abinitParaLabel = new javax.swing.JLabel();
        getLogFileButton = new javax.swing.JButton();

        openClustepInputFileLabel.setText("Open the Clustep input file");

        displayClustepInputFileButton.setText("Display");
        displayClustepInputFileButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                displayClustepInputFileButtonActionPerformed(evt);
            }
        });

        geditClustepInputButton.setText("Edit");
        geditClustepInputButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                geditClustepInputButtonActionPerformed(evt);
            }
        });

        openClustepInputFileDialogButton.setText("...");
        openClustepInputFileDialogButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openClustepInputFileDialogButtonActionPerformed(evt);
            }
        });

        openClustepPositionFileLabel.setText("Open the Clustep position file");

        displayClustepPositionFileButton.setText("Display");
        displayClustepPositionFileButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                displayClustepPositionFileButtonActionPerformed(evt);
            }
        });

        geditClustepPositionButton.setText("Edit");
        geditClustepPositionButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                geditClustepPositionButtonActionPerformed(evt);
            }
        });

        openClustepPositionFileDialogButton.setText("...");
        openClustepPositionFileDialogButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openClustepPositionFileDialogButtonActionPerformed(evt);
            }
        });

        sendSIMClustepButton.setText("<HTML> <center> <b>Send the simulation</b><br> the simulation will start at server side </HTML>");
        sendSIMClustepButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sendSIMClustepButtonActionPerformed(evt);
            }
        });

        sendClustepCheckBox.setText("Send CLUSTEP source code and compile");

        getEvolutionFileButton.setText("Download Evolution File");
        getEvolutionFileButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                getEvolutionFileButtonActionPerformed(evt);
            }
        });

        getFilmFileButton.setText("Download Film File");
        getFilmFileButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                getFilmFileButtonActionPerformed(evt);
            }
        });

        needSGECheckBox.setForeground(new java.awt.Color(0, 128, 0));
        needSGECheckBox.setSelected(true);
        needSGECheckBox.setText("SGE script");
        needSGECheckBox.setToolTipText("If checked, a SGE script is created and is used to submit the calculation job.");
        needSGECheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                needSGECheckBoxActionPerformed(evt);
            }
        });

        SGEconfigPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)), "SGE script configuration", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("DejaVu Sans", 3, 14), java.awt.Color.darkGray)); // NOI18N

        timeLabel.setText("Time [h]");

        nodesLabel.setText("# nodes");

        ramLabel.setText("RAM [Mb]");

        hdmLabel.setText("HDM [Mb]");

        timeTextField.setText("1");

        nodesTextField.setText("1");
        nodesTextField.setEnabled(false);

        ramTextField.setText("200");

        hdmTextField.setText("2000");
        hdmTextField.setEnabled(false);

        emailLabel.setText("E-mail where to send feedback");

        emailTextField.setText("email@provider.ext");

        org.jdesktop.layout.GroupLayout SGEconfigPanelLayout = new org.jdesktop.layout.GroupLayout(SGEconfigPanel);
        SGEconfigPanel.setLayout(SGEconfigPanelLayout);
        SGEconfigPanelLayout.setHorizontalGroup(
            SGEconfigPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(SGEconfigPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(SGEconfigPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, timeTextField)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, timeLabel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .add(18, 18, 18)
                .add(SGEconfigPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                    .add(nodesTextField)
                    .add(nodesLabel))
                .add(18, 18, 18)
                .add(SGEconfigPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                    .add(ramTextField)
                    .add(ramLabel))
                .add(18, 18, 18)
                .add(SGEconfigPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                    .add(hdmTextField)
                    .add(hdmLabel))
                .add(18, 18, 18)
                .add(SGEconfigPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(emailLabel)
                    .add(emailTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 217, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        SGEconfigPanelLayout.setVerticalGroup(
            SGEconfigPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(SGEconfigPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(SGEconfigPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(SGEconfigPanelLayout.createSequentialGroup()
                        .add(SGEconfigPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(hdmLabel)
                            .add(emailLabel))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(SGEconfigPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(hdmTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(emailTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                    .add(SGEconfigPanelLayout.createSequentialGroup()
                        .add(ramLabel)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(ramTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(SGEconfigPanelLayout.createSequentialGroup()
                        .add(nodesLabel)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(nodesTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(SGEconfigPanelLayout.createSequentialGroup()
                        .add(timeLabel)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(timeTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        buttonGroup1.add(sequentialCheckBox);
        sequentialCheckBox.setForeground(java.awt.Color.red);
        sequentialCheckBox.setSelected(true);
        sequentialCheckBox.setText("Sequential");
        sequentialCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sequentialCheckBoxActionPerformed(evt);
            }
        });

        buttonGroup1.add(parallelCheckBox);
        parallelCheckBox.setForeground(java.awt.Color.blue);
        parallelCheckBox.setText("Parallel");
        parallelCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                parallelCheckBoxActionPerformed(evt);
            }
        });

        abinitParaTextField.setEnabled(false);

        abinitParaLabel.setText("(local max = ?)");
        abinitParaLabel.setEnabled(false);

        getLogFileButton.setText("Download log File");
        getLogFileButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                getLogFileButtonActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(layout.createSequentialGroup()
                        .add(openClustepInputFileLabel)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .add(displayClustepInputFileButton)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(geditClustepInputButton))
                    .add(sendSIMClustepButton)
                    .add(layout.createSequentialGroup()
                        .add(openClustepPositionFileLabel)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .add(displayClustepPositionFileButton)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(geditClustepPositionButton))
                    .add(layout.createSequentialGroup()
                        .add(openClustepInputFileDialogButton)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(openClustepInputFileTextField))
                    .add(layout.createSequentialGroup()
                        .add(openClustepPositionFileDialogButton)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(openClustepPositionFileTextField))
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                        .add(0, 0, Short.MAX_VALUE)
                        .add(SGEconfigPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(layout.createSequentialGroup()
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(sendClustepCheckBox)
                            .add(layout.createSequentialGroup()
                                .add(needSGECheckBox)
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(sequentialCheckBox)
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(parallelCheckBox)
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(abinitParaTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 40, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(abinitParaLabel))
                            .add(layout.createSequentialGroup()
                                .add(getEvolutionFileButton)
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(getFilmFileButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 161, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(getLogFileButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 161, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                        .add(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(openClustepInputFileLabel)
                    .add(geditClustepInputButton)
                    .add(displayClustepInputFileButton))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(openClustepInputFileDialogButton)
                    .add(openClustepInputFileTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(openClustepPositionFileLabel)
                    .add(geditClustepPositionButton)
                    .add(displayClustepPositionFileButton))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(openClustepPositionFileDialogButton)
                    .add(openClustepPositionFileTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .add(18, 18, 18)
                .add(sendSIMClustepButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(39, 39, 39)
                .add(sendClustepCheckBox)
                .add(18, 18, 18)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(getEvolutionFileButton)
                    .add(getFilmFileButton)
                    .add(getLogFileButton))
                .add(18, 18, 18)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                        .add(sequentialCheckBox)
                        .add(parallelCheckBox)
                        .add(abinitParaTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(abinitParaLabel))
                    .add(needSGECheckBox))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(SGEconfigPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void sendSIMClustepButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sendSIMClustepButtonActionPerformed
        sendSIMClustepButton.setEnabled(false);
        Runnable r = new Runnable() {
            @Override
            public void run() {
                
                // Use local machine to enable compilation
                // TODO get machine from combobox !
                Machine mach = new LocalMachine();
                
                
                if (mach.getType() == Machine.LOCAL_MACHINE && Utils.osName().startsWith("Windows")) {
                    MF.printERR("Please connect to a remote CLUSTEP host before submitting a simulation !");
                    sendSIMClustepButton.setEnabled(true);
                    return;
                }

                if(!mach.isConnected())
                {
                    mach.connection(MF);
                }
                
                String rootPath = mach.getSimulationPath();
                
                if (rootPath == null || rootPath.equals("")) {
                    rootPath = ".";
                }
                mach.createTree(rootPath, MF);
                if(mach.getType() == Machine.REMOTE_MACHINE || mach.getType() == Machine.GATEWAY_MACHINE)
                {
                    MF.getLocalExec().createTree(rootPath);
                }

                String ClustepProgPath = "";
                if (mach.getType() == Machine.GATEWAY_MACHINE || mach.getType() == Machine.REMOTE_MACHINE) {
                    ClustepProgPath = "~/CLUSTEP/clustep0";
                } else {
                    ClustepProgPath = "../../CLUSTEP/clustep0";
                }

                String clustepFolder = "clustep";

                // ***************************************************************

                String cwd = "";

                String CMD = "pwd";

                RetMSG retmsg;
                retmsg = mach.sendCommand(CMD, MF);
                if (retmsg.getRetCode() == RetMSG.SUCCES) {
                    MF.printOUT("PWD: " + retmsg.getRetMSG());
                    cwd = MF.removeEndl(retmsg.getRetMSG());
                } else {
                    //printERR("Error (RetVal = " + retmsg.getRetCode() + "): " + retmsg.getRetMSG());
                    MF.printERR("Error: " + retmsg.getRetMSG() + " !");
                }
                
                // ***************************************************************

                String sep = Utils.fileSeparator();

                String inputFile = openClustepInputFileTextField.getText();

                String inputFileName = Utils.getLastToken(inputFile.replace('\\', '/'), "/");

                // Test de l'existance de inputfile
                if (!Utils.exists(inputFile)) {
                    MF.printERR("The file " + inputFile + " doesn't exist !");
                    sendSIMClustepButton.setEnabled(true);
                    return;
                }

                String simName = null;
                if (inputFileName != null) {
                    int idx = inputFileName.indexOf('-');
                    if (idx > 0 && idx < inputFileName.length()) {
                        simName = inputFileName.substring(0, idx);
                    } else {
                        simName = inputFileName;
                    }
                }

                // Creation du dossier clustepFolder local
                MF.getLocalExec().mkdir(rootPath + "/" + clustepFolder);
                // Creation du dossier simName dans clustepFolder local
                MF.getLocalExec().mkdir(rootPath + "/" + clustepFolder + "/" + simName);

                if (mach.getType() == Machine.REMOTE_MACHINE || mach.getType() == Machine.GATEWAY_MACHINE) {
                    // Creation du dossier clustepFolder
                    mach.mkdir(rootPath + "/" + clustepFolder, MF);
                    // Creation du dossier simName dans clustepFolder
                    mach.mkdir(rootPath + "/" + clustepFolder + "/" + simName, MF);
                }

                if (sendClustepCheckBox.isSelected()) {
                    mach.mkdir("./CLUSTEP", MF);
                    if(mach.getType() == Machine.REMOTE_MACHINE || mach.getType() == Machine.GATEWAY_MACHINE)
                    {
                        mach.putFile("./CLUSTEP_src.tar.gz ./CLUSTEP_src.tar.gz", MF);
                    }

                    // Unzip the compressed file CLUSTEP_src.tar.gz
                    mach.sendCommand("tar -zxf ./CLUSTEP_src.tar.gz", MF);

                    // Compilation de clustep0
                    mach.sendCommand("make -C ./CLUSTEP_src/", MF);
                    mach.sendCommand("mv ./CLUSTEP_src/clustep0 ./CLUSTEP", MF);
                    mach.sendCommand("rm -rf ./CLUSTEP_src/", MF);
                    
                    if(mach.getType() == Machine.REMOTE_MACHINE || mach.getType() == Machine.GATEWAY_MACHINE)
                    {
                        mach.sendCommand("rm -f ./CLUSTEP_src.tar.gz", MF);
                    }
                }

                if (!inputFile.equals("")) {
                    int nbProc;
                    if (abinitParaTextField.isEnabled()) { // Tjs actif pour cette version du gui
                        try {
                            nbProc = Integer.parseInt(abinitParaTextField.getText());
                        } finally {
                            MF.printDEB("Please set up the number of processors to use ! nbProc was set to 1!");
                            nbProc = 1;
                        }
                    } else {
                        nbProc = 1;
                    }

                    if (needSGECheckBox.isSelected()) {
                        int time, nodes, ram, hdm;
                        String email;
                        try {
                            time = Integer.parseInt(timeTextField.getText());
                            nodes = Integer.parseInt(nodesTextField.getText());
                            ram = Integer.parseInt(ramTextField.getText());
                            hdm = Integer.parseInt(hdmTextField.getText());
                            email = emailTextField.getText();
                        } catch (Exception e) {
                            //printERR("Exception in sendSIMButtonActionPerformed:" + e + "");
                            MF.printERR("The SGE script configuration is probably wrong !");
                            sendSIMClustepButton.setEnabled(true);
                            return;
                        }
                        // Création du script SGE
                        try {
                            //String rootPath_ = (new File(rootPath)).getCanonicalPath();

                            String PBSfileName = rootPath + sep + clustepFolder + sep
                                    + simName + sep + simName + ".SGE.sh";
                            OutputStreamWriter fw = new OutputStreamWriter(new FileOutputStream(PBSfileName), MF.CharSet);
                            //FileWriter fw = new FileWriter(PBSfileName);
                            BufferedWriter bw = new BufferedWriter(fw);
                            PrintWriter pw = new PrintWriter(bw);

                            //*********************************************************************************************
                            String fileContent = "#!/bin/bash" + "\n"
                                    + "#" + "\n"
                                    + "# On old Green node" + "\n"
                                    + "#$ -l nb=false" + "\n"
                                    + "#" + "\n"
                                    + "# Ask for pe=parrallel environment, snode or openmpi" + "\n"
                                    + "# snode= same node, as the shared memory communication is the fastest" + "\n"
                                    + "#$ -pe openmpi 1" + "\n"
                                    + "# -pe snode8 8" + "\n"
                                    + "\n"
                                    + "# keep current working directory" + "\n"
                                    + "#$ -cwd" + "\n"
                                    + "\n"
                                    + "#$ -o SGE_out-$JOB_ID.log" + "\n"
                                    + "#$ -e SGE_err-$JOB_ID.log" + "\n"
                                    + "\n"
                                    + "# give a name to your job" + "\n"
                                    + "#$ -N " + simName + "\n"
                                    + "\n"
                                    + "# keep all the defined variables" + "\n"
                                    + "#$ -V" + "\n"
                                    + "#$ -l nb=false" + "\n"
                                    + "\n"
                                    + "# not mandatory: highmem=true (hm=true) for 32GB node" + "\n"
                                    + "# or hm=false for 16GB node" + "\n"
                                    + "# no hm argument does not take about the kind of node ram (16/32)" + "\n"
                                    + "# -l hm=true" + "\n"
                                    + "\n"
                                    + "# IMPORTANT: You need to specify the mem_free" + "\n"
                                    + "# h_vmem can also be set but mf is mandatory!" + "\n"
                                    + "# max 31G if hm=true and max 15G if hm=false" + "\n"
                                    + "#$ -l mf=" + ram + "M" + "\n"
                                    + "\n"
                                    + "# Specify the requested time" + "\n"
                                    + "#$ -l h_rt=" + time + ":00:00" + "\n"
                                    + "\n"
                                    + "# To be informed by email (besa= begin,end,stop,abort)" + "\n"
                                    + "#$ -M " + email + "\n"
                                    + "#$ -m besa" + "\n"
                                    //+ "# ---------------------------" + "\n"
                                    + "\n"
                                    + "echo \"Project " + simName + " is running!\"" + "\n"
                                    + "cd " + rootPath + "/" + clustepFolder + "/" + simName + "/" + "\n"
                                    + ClustepProgPath + " < " + cwd + "/"
                                    + rootPath.replaceFirst("./", "") + "/" + clustepFolder + "/"
                                    + simName + "/" + simName + ".files >& " + cwd + "/"
                                    + rootPath.replaceFirst("./", "") + "/" + clustepFolder
                                    + "/" + simName + "/" + simName + ".log";

                            pw.print(fileContent);
                            //*********************************************************************************************

                            pw.println();
                            pw.close();
                            bw.close();
                            fw.close();
                        } catch (IOException e) {
                            //printERR("Exception in sendSIMButtonActionPerformed:" + e + "");
                            MF.printERR("The SGE script could not be created !");
                            sendSIMClustepButton.setEnabled(true);
                            return;
                        }
                    } else {
                        // Création du script BASH
                        try {
                            String BASHfileName = rootPath + sep + clustepFolder + sep
                                    + simName + sep + simName + ".sh";

                            OutputStreamWriter fw = new OutputStreamWriter(new FileOutputStream(BASHfileName), MF.CharSet);
                            //FileWriter fw = new FileWriter(BASHfileName);

                            BufferedWriter bw = new BufferedWriter(fw);
                            PrintWriter pw = new PrintWriter(bw);
                            pw.println("#!/bin/bash");
                            pw.println("echo \"Project " + simName + " is running!\"");
                            pw.println("cd " + rootPath + "/" + clustepFolder + "/" + simName + "/");
                            pw.print(ClustepProgPath + " < " + cwd + "/"
                                    + rootPath.replaceFirst("./", "") + "/" + clustepFolder + "/"
                                    + simName + "/" + simName + ".files >& " + cwd + "/"
                                    + rootPath.replaceFirst("./", "") + "/" + clustepFolder
                                    + "/" + simName + "/" + simName + ".log &");
                            pw.println();
                            pw.close();
                            bw.close();
                            fw.close();
                        } catch (IOException e) {
                            //printDEB("Exception in sendSIMButtonActionPerformed:" + e + "");
                            MF.printERR("The bash script could not be created !");
                            sendSIMClustepButton.setEnabled(true);
                            return;
                        }
                    }

                    // Envoie (copie) du fichier d'input *******************************************************************
                    String inputFileR = rootPath + "/" + clustepFolder + "/" + simName + "/" + simName + "-input";
                    if (mach.getType() == Machine.REMOTE_MACHINE || mach.getType() == Machine.GATEWAY_MACHINE) {
                        if (Utils.osName().startsWith("Windows")) {
                            Utils.dos2unix(new File(inputFile));
                        }
                    }
                    mach.putFile(inputFile + " " + inputFileR, MF);

                    //                    if (remoteGatewayRadioButton.isSelected() || remoteAbinitRadioButton.isSelected()) {
                    //                        if (Utils.osName().startsWith("Windows")) {
                    //                            sendCommand("dos2unix " + inputFileR);
                    //                        }
                    //                    }

                    // Envoie (copie) du fichier des positions atomiques ***************************************************
                    String positionFile = openClustepPositionFileTextField.getText();
                    String positionFileR = rootPath + "/" + clustepFolder + "/" + simName + "/" + simName + "-pos";
                    if (mach.getType() == Machine.REMOTE_MACHINE || mach.getType() == Machine.GATEWAY_MACHINE) {
                        if (Utils.osName().startsWith("Windows")) {
                            Utils.dos2unix(new File(positionFile));
                        }
                    }
                    mach.putFile(positionFile + " " + positionFileR, MF);

                    //                    if (remoteGatewayRadioButton.isSelected() || remoteAbinitRadioButton.isSelected()) {
                    //                        if (Utils.osName().startsWith("Windows")) {
                    //                            sendCommand("dos2unix " + positionFileR);
                    //                        }
                    //                    }

                    // Création du fichier de configuration
                    try {
                        String FILESfileName = rootPath + sep + clustepFolder
                                + sep + simName + sep + simName + ".files";
                        OutputStreamWriter fw = new OutputStreamWriter(new FileOutputStream(FILESfileName), MF.CharSet);
                        //FileWriter fw = new FileWriter(FILESfileName);
                        BufferedWriter bw = new BufferedWriter(fw);
                        PrintWriter pw = new PrintWriter(bw);
                        String configFileContent = "";
                        configFileContent += simName + "-input\n";
                        configFileContent += simName + "-evol.dat\n";
                        configFileContent += simName + "-pos\n";
                        configFileContent += simName + "-film.xyz\n";
                        pw.print(configFileContent);
                        pw.close();
                        bw.close();
                        fw.close();
                    } catch (IOException e) {
                        //printERR(e.getMessage());
                        MF.printERR("The configuration file (*.files) could not be created !");
                        sendSIMClustepButton.setEnabled(true);
                        return;
                    }

                    if (mach.getType() == Machine.REMOTE_MACHINE || mach.getType() == Machine.GATEWAY_MACHINE) {
                        String configFile = rootPath + sep + clustepFolder + sep + simName + sep + simName + ".files";
                        String configFileR = rootPath + "/" + clustepFolder + "/" + simName + "/" + simName + ".files";
                        if (Utils.osName().startsWith("Windows")) {
                            Utils.dos2unix(new File(configFile));
                        }
                        // Envoie du fichier de configuration
                        mach.putFile(configFile + " " + configFileR, MF);

                        //                        if (Utils.osName().startsWith("Windows")) {
                        //                            sendCommand("dos2unix " + configFileR);
                        //                        }
                    }

                    if (needSGECheckBox.isSelected()) {
                        if (mach.getType() == Machine.REMOTE_MACHINE || mach.getType() == Machine.GATEWAY_MACHINE) {
                            String sgeSHFile = rootPath + sep + clustepFolder + sep + simName + sep + simName + ".SGE.sh";
                            String sgeSHFileR = rootPath + "/" + clustepFolder + "/" + simName + "/" + simName + ".SGE.sh";
                            if (Utils.osName().startsWith("Windows")) {
                                Utils.dos2unix(new File(sgeSHFile));
                            }
                            // Envoie du fichier SGE
                            mach.putFile(sgeSHFile + " " + sgeSHFileR, MF);

                            //                            if (Utils.osName().startsWith("Windows")) {
                            //                                sendCommand("dos2unix " + sgeSHFileR);
                            //                            }
                        }
                        // lancement des commandes d'exécution de la simulation
                        mach.sendCommand("qsub " + rootPath + "/" + clustepFolder + "/"
                                + simName + "/" + simName + ".SGE.sh", MF);
                    } else {
                        String SHFile = rootPath + sep + clustepFolder + sep + simName + sep + simName + ".sh";
                        String SHFileR = rootPath + "/" + clustepFolder + "/" + simName + "/" + simName + ".sh";
                        if (mach.getType() == Machine.REMOTE_MACHINE || mach.getType() == Machine.GATEWAY_MACHINE) {
                            if (Utils.osName().startsWith("Windows")) {
                                Utils.dos2unix(new File(SHFile));
                            }
                            // Envoie du fichier BASH
                            mach.putFile(SHFile + " " + SHFileR, MF);

                            //                            if (Utils.osName().startsWith("Windows")) {
                            //                                sendCommand("dos2unix " + SHFileR);
                            //                            }
                        }
                        // lancement des commandes d'exécution de la simulation
                        mach.sendCommand("bash " + SHFileR, MF);
                    }
                } else {
                    MF.printERR("Please setup the inputfile textfield !");
                    sendSIMClustepButton.setEnabled(true);
                    return;
                }

                if (mach.getType() == Machine.LOCAL_MACHINE) {
                    MF.printOUT("The simulation was submitted to the local CLUSTEP machine.");
                } else {
                    MF.printOUT("The simulation was submitted to the remote CLUSTEP machine " + mach.getName());
                }
                MF.printDEB("The submission thread ended successfully! (Clustep)");
                sendSIMClustepButton.setEnabled(true);
            }
        };

        Thread t = new Thread(r);
        t.start();
    }//GEN-LAST:event_sendSIMClustepButtonActionPerformed

    private void displayClustepInputFileButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_displayClustepInputFileButtonActionPerformed
        MF.clustepInputFileDisplayer.setVisible(true);
        // TODO : pour quand ce sera éditable
        //clustepInputFileDisplayer.setEditable(true);

        String fileContent = "";

        try {
            File file = new File(openClustepInputFileTextField.getText());

            FileInputStream fis = new FileInputStream(file);

            // Here BufferedInputStream is added for fast reading.
            BufferedInputStream bis = new BufferedInputStream(fis);
            DataInputStream dis = new DataInputStream(bis);

            while (dis.available() != 0) {
                fileContent += dis.readLine() + "\n";
            }

            // dispose all the resources after using them.
            fis.close();
            bis.close();
            dis.close();

        } catch (FileNotFoundException e) {
            MF.printERR(e.getMessage());
        } catch (IOException e) {
            MF.printERR(e.getMessage());
        }

        MF.clustepInputFileDisplayer.setText(fileContent);
    }//GEN-LAST:event_displayClustepInputFileButtonActionPerformed

    private void geditClustepInputButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_geditClustepInputButtonActionPerformed

        String fileName = openClustepInputFileTextField.getText();

        MF.editFile(fileName, true);
    }//GEN-LAST:event_geditClustepInputButtonActionPerformed

    private void openClustepInputFileDialogButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openClustepInputFileDialogButtonActionPerformed
        JFileChooser fc = new JFileChooser(".");
        File currDir = new File(".");
        String currPath = currDir.getAbsolutePath();
        String basePath = basePath = currPath.replace("\\", "/").replace(".", "");
        MF.printDEB(basePath);
        fc.setMultiSelectionEnabled(false);

        int retValue = fc.showOpenDialog(this);
        if (retValue == JFileChooser.APPROVE_OPTION) {
            File file = fc.getSelectedFile();
            String relPath = file.getAbsolutePath().replace("\\", "/").replace(basePath, "./");
            openClustepInputFileTextField.setText(relPath);
        }
    }//GEN-LAST:event_openClustepInputFileDialogButtonActionPerformed

    private void displayClustepPositionFileButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_displayClustepPositionFileButtonActionPerformed
        MF.clustepPositionFileDisplayer.setVisible(true);
        // TODO : pour quand ce sera éditable
        //clustepPositionFileDisplayer.setEditable(true);

        String fileContent = "";

        try {
            File file = new File(openClustepPositionFileTextField.getText());

            FileInputStream fis = new FileInputStream(file);

            // Here BufferedInputStream is added for fast reading.
            BufferedInputStream bis = new BufferedInputStream(fis);
            DataInputStream dis = new DataInputStream(bis);

            while (dis.available() != 0) {
                fileContent += dis.readLine() + "\n";
            }

            // dispose all the resources after using them.
            fis.close();
            bis.close();
            dis.close();

        } catch (FileNotFoundException e) {
            MF.printERR(e.getMessage());
        } catch (IOException e) {
            MF.printERR(e.getMessage());
        }

        MF.clustepPositionFileDisplayer.setText(fileContent);
    }//GEN-LAST:event_displayClustepPositionFileButtonActionPerformed

    private void geditClustepPositionButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_geditClustepPositionButtonActionPerformed

        String fileName = openClustepPositionFileTextField.getText();

        MF.editFile(fileName, true);
    }//GEN-LAST:event_geditClustepPositionButtonActionPerformed

    private void openClustepPositionFileDialogButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openClustepPositionFileDialogButtonActionPerformed
        JFileChooser fc = new JFileChooser(".");
        File currDir = new File(".");
        String currPath = currDir.getAbsolutePath();
        String basePath = basePath = currPath.replace("\\", "/").replace(".", "");
        MF.printDEB(basePath);
        fc.setMultiSelectionEnabled(false);

        int retValue = fc.showOpenDialog(this);
        if (retValue == JFileChooser.APPROVE_OPTION) {
            File file = fc.getSelectedFile();
            String relPath = file.getAbsolutePath().replace("\\", "/").replace(basePath, "./");
            openClustepPositionFileTextField.setText(relPath);
        }
    }//GEN-LAST:event_openClustepPositionFileDialogButtonActionPerformed

    private void getEvolutionFileButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_getEvolutionFileButtonActionPerformed
        Runnable r = new Runnable() {
            @Override
            public void run() {
                // TODO use combobox !
                Machine mach = new LocalMachine();
                if(!mach.isConnected())
                {
                    mach.connection(MF);
                }

                String rootPath = mach.getSimulationPath();
                if(rootPath == null || rootPath.isEmpty())
                {
                    rootPath = ".";
                }
                
                String clustepFolder = "clustep";

                String inputFile = "";
                String inputFileName = "";

                inputFile = openClustepInputFileTextField.getText();
                inputFileName = Utils.getLastToken(inputFile.replace('\\', '/'), "/");

                // Test de l'existance de inputfile
                if (!Utils.exists(inputFile)) {
                    MF.printERR("The file " + inputFile + " doesn't exist !");
                    getEvolutionFileButton.setEnabled(true);
                    return;
                }

                String simName = null;
                if (inputFileName != null) {
                    if (!inputFileName.equals("")) {
                        int idx = inputFileName.indexOf('-');
                        if (idx > 0 && idx < inputFileName.length()) {
                            simName = inputFileName.substring(0, idx);
                        } else {
                            simName = inputFileName;
                        }
                    } else {
                        MF.printERR("inputFileName == \"\"");
                        return;
                    }
                } else {
                    MF.printERR("inputFileName == null");
                    return;
                }

                if (!inputFile.equals("")) {

                    String fileName = rootPath + "/" + clustepFolder + "/"
                            + simName + "/" + simName + "-evol.dat";

                    if (!Utils.exists(fileName)) {
                        // Réception (copie) du fichier d'output si celui-ci est distant
                        if (mach.getType() == Machine.REMOTE_MACHINE || mach.getType() == Machine.GATEWAY_MACHINE) {
                            //                            if (Utils.osName().startsWith("Windows")) {
                            //                                sendCommand("unix2dos " + fileName);
                            //                            }
                            mach.getFile(fileName + " " + fileName, MF);
                            //                            if (Utils.osName().startsWith("Windows")) {
                            //                                sendCommand("dos2unix " + fileName);
                            //                            }
                            if (Utils.osName().startsWith("Windows")) {
                                Utils.unix2dos(new File(fileName));
                            }
                        }
                    } else {
                        MF.printOUT("File " + fileName + " exists in your local filetree!\n"
                                + "Please remove the local file before you download the new file version!");
                    }

                    // ****************************************************************************
                    // Tester l'existance du fichier
                    MF.editFile(fileName, false);
                    // ****************************************************************************
                } else {
                    MF.printERR("Please setup the inputfile textfield !");
                    return;
                }
            }
        };

        Thread t = new Thread(r);
        t.start();
    }//GEN-LAST:event_getEvolutionFileButtonActionPerformed

    private void getFilmFileButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_getFilmFileButtonActionPerformed
        Runnable r = new Runnable() {
            @Override
            public void run() {
                // TODO get machine from combobox
                Machine mach = new LocalMachine();
                
                if(!mach.isConnected())
                {
                    mach.connection(MF);
                }

                String rootPath = mach.getSimulationPath();
                if(rootPath == null || rootPath.isEmpty())
                {
                    rootPath = ".";
                }
                String clustepFolder = "clustep";

                String inputFile = "";
                String inputFileName = "";

                inputFile = openClustepInputFileTextField.getText();
                inputFileName = Utils.getLastToken(inputFile.replace('\\', '/'), "/");

                // Test de l'existance de inputfile
                if (!Utils.exists(inputFile)) {
                    MF.printERR("The file " + inputFile + " doesn't exist !");
                    getEvolutionFileButton.setEnabled(true);
                    return;
                }

                String simName = null;
                if (inputFileName != null) {
                    if (!inputFileName.equals("")) {
                        int idx = inputFileName.indexOf('-');
                        if (idx > 0 && idx < inputFileName.length()) {
                            simName = inputFileName.substring(0, idx);
                        } else {
                            simName = inputFileName;
                        }
                    } else {
                        MF.printERR("inputFileName == \"\"");
                        return;
                    }
                } else {
                    MF.printERR("inputFileName == null");
                    return;
                }

                if (!inputFile.equals("")) {

                    String fileName = rootPath + "/" + clustepFolder + "/"
                            + simName + "/" + simName + "-film.xyz";

                    if (!Utils.exists(fileName)) {
                        // Réception (copie) du fichier d'output si celui-ci est distant
                        if (mach.getType() == Machine.REMOTE_MACHINE || mach.getType() == Machine.GATEWAY_MACHINE) {
                            //                            if (Utils.osName().startsWith("Windows")) {
                            //                                sendCommand("unix2dos " + fileName);
                            //                            }
                            mach.getFile(fileName + " " + fileName, MF);
                            //                            if (Utils.osName().startsWith("Windows")) {
                            //                                sendCommand("dos2unix " + fileName);
                            //                            }
                            if (Utils.osName().startsWith("Windows")) {
                                Utils.unix2dos(new File(fileName));
                            }
                        }
                    } else {
                        MF.printOUT("File " + fileName + " exists in your local filetree!\n"
                                + "Please remove the local file before you download the new file version!");
                    }

                    // ****************************************************************************
                    // Tester l'existance du fichier
                    MF.editFile(fileName.replace("/./", "/"), false);

                    if (!Utils.exists(fileName)) {
                        MF.printERR("File " + fileName + " doesn't exist !");
                        return;
                    } else {
                        if (Utils.osName().equals("Linux")) {
                            MF.localCommand("java -jar Jmol.jar " + fileName.replace("/./", "/"));
                        } else if (Utils.osName().equals("Mac OS X")) {
                            MF.localCommand("java -jar Jmol.jar " + fileName.replace("/./", "/"));
                        } else {
                            MF.localCommand("java -jar Jmol.jar " + fileName.replace("/./", "/"));
                        }
                    }
                    // ****************************************************************************
                } else {
                    MF.printERR("Please setup the inputfile textfield !");
                    return;
                }
            }
        };

        Thread t = new Thread(r);
        t.start();
    }//GEN-LAST:event_getFilmFileButtonActionPerformed

    private void needSGECheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_needSGECheckBoxActionPerformed
        if (needSGECheckBox.isSelected()) {
            SGEconfigPanel.setVisible(true);
        } else {
            SGEconfigPanel.setVisible(false);
        }
    }//GEN-LAST:event_needSGECheckBoxActionPerformed

    private void sequentialCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sequentialCheckBoxActionPerformed
        sequentialCheckBox.setForeground(Color.red);
        parallelCheckBox.setForeground(Color.blue);

        abinitParaTextField.setEnabled(false);
        abinitParaLabel.setEnabled(false);
    }//GEN-LAST:event_sequentialCheckBoxActionPerformed

    private void parallelCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_parallelCheckBoxActionPerformed
        parallelCheckBox.setForeground(Color.red);
        sequentialCheckBox.setForeground(Color.blue);

        abinitParaTextField.setEnabled(true);
        abinitParaLabel.setEnabled(true);
    }//GEN-LAST:event_parallelCheckBoxActionPerformed

    private void getLogFileButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_getLogFileButtonActionPerformed
        Runnable r = new Runnable() {
            @Override
            public void run() {
                // TODO use combobox !
                Machine mach = new LocalMachine();
                if(!mach.isConnected())
                {
                    mach.connection(MF);
                }

                String rootPath = mach.getSimulationPath();
                if(rootPath == null || rootPath.isEmpty())
                {
                    rootPath = ".";
                }
                
                String clustepFolder = "clustep";

                String inputFile = "";
                String inputFileName = "";

                inputFile = openClustepInputFileTextField.getText();
                inputFileName = Utils.getLastToken(inputFile.replace('\\', '/'), "/");

                // Test de l'existance de inputfile
                if (!Utils.exists(inputFile)) {
                    MF.printERR("The file " + inputFile + " doesn't exist !");
                    getEvolutionFileButton.setEnabled(true);
                    return;
                }

                String simName = null;
                if (inputFileName != null) {
                    if (!inputFileName.equals("")) {
                        int idx = inputFileName.indexOf('-');
                        if (idx > 0 && idx < inputFileName.length()) {
                            simName = inputFileName.substring(0, idx);
                        } else {
                            simName = inputFileName;
                        }
                    } else {
                        MF.printERR("inputFileName == \"\"");
                        return;
                    }
                } else {
                    MF.printERR("inputFileName == null");
                    return;
                }

                if (!inputFile.equals("")) {

                    String fileName = rootPath + "/" + clustepFolder + "/"
                            + simName + "/" + simName + ".log";

                    if (!Utils.exists(fileName)) {
                        // Réception (copie) du fichier d'output si celui-ci est distant
                        if (mach.getType() == Machine.REMOTE_MACHINE || mach.getType() == Machine.GATEWAY_MACHINE) {
                            //                            if (Utils.osName().startsWith("Windows")) {
                            //                                sendCommand("unix2dos " + fileName);
                            //                            }
                            mach.getFile(fileName + " " + fileName, MF);
                            //                            if (Utils.osName().startsWith("Windows")) {
                            //                                sendCommand("dos2unix " + fileName);
                            //                            }
                            if (Utils.osName().startsWith("Windows")) {
                                Utils.unix2dos(new File(fileName));
                            }
                        }
                    } else {
                        MF.printOUT("File " + fileName + " exists in your local filetree!\n"
                                + "Please remove the local file before you download the new file version!");
                    }

                    // ****************************************************************************
                    // Tester l'existance du fichier
                    MF.editFile(fileName, false);
                    // ****************************************************************************
                } else {
                    MF.printERR("Please setup the inputfile textfield !");
                    return;
                }
            }
        };

        Thread t = new Thread(r);
        t.start();
    }//GEN-LAST:event_getLogFileButtonActionPerformed

    public JTextField ramTextField() {
        return ramTextField;
    }
    
    public JTextField timeTextField() {
        return timeTextField;
    }
    
    public JTextField nodesTextField() {
        return nodesTextField;
    }
    
    public JTextField hdmTextField() {
        return hdmTextField;
    }
    
    public JTextField emailTextField() {
        return emailTextField;
    }
    
    public JTextField abinitParaTextField() {
        return abinitParaTextField;
    }
    
    public JCheckBox needSGECheckBox() {
        return needSGECheckBox;
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel SGEconfigPanel;
    private javax.swing.JLabel abinitParaLabel;
    private javax.swing.JTextField abinitParaTextField;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JButton displayClustepInputFileButton;
    private javax.swing.JButton displayClustepPositionFileButton;
    private javax.swing.JLabel emailLabel;
    private javax.swing.JTextField emailTextField;
    private javax.swing.JButton geditClustepInputButton;
    private javax.swing.JButton geditClustepPositionButton;
    private javax.swing.JButton getEvolutionFileButton;
    private javax.swing.JButton getFilmFileButton;
    private javax.swing.JButton getLogFileButton;
    private javax.swing.JLabel hdmLabel;
    private javax.swing.JTextField hdmTextField;
    private javax.swing.JCheckBox needSGECheckBox;
    private javax.swing.JLabel nodesLabel;
    private javax.swing.JTextField nodesTextField;
    private javax.swing.JButton openClustepInputFileDialogButton;
    private javax.swing.JLabel openClustepInputFileLabel;
    public javax.swing.JTextField openClustepInputFileTextField;
    private javax.swing.JButton openClustepPositionFileDialogButton;
    private javax.swing.JLabel openClustepPositionFileLabel;
    public javax.swing.JTextField openClustepPositionFileTextField;
    private javax.swing.JCheckBox parallelCheckBox;
    private javax.swing.JLabel ramLabel;
    private javax.swing.JTextField ramTextField;
    private javax.swing.JCheckBox sendClustepCheckBox;
    private javax.swing.JButton sendSIMClustepButton;
    private javax.swing.JCheckBox sequentialCheckBox;
    private javax.swing.JLabel timeLabel;
    private javax.swing.JTextField timeTextField;
    // End of variables declaration//GEN-END:variables
}
